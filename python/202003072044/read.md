## 操作系统实践
### 前言、实现支持异步任务的线程池
- 线程池
 - JAVA:ThreadPoolExecutor
 - python3:ThreadPoolExecutor
 - 很多语言都提供了线程池
 - 不再局限与如何使用

	用户-->普通任务          -->        任务队列  -->      线程池
	        ||                           ||               ||
	        ||                           ||               ||
	   1、提交任务；             1、暂时存放任务；   1、不断从任务队列获取任务执行
	   2、无需获取任务结果；      2、等待线程池执行;
### 一、python同步原语
##### (1)、互斥锁
 `lock = threading,Lock()` 
 `lock.acquire()`
 `lock.release()`
##### (2)、条件变量
 `condition = threading.Condition()`
 `condition.acquire()`
 `condition.release()`
 `condition.wait()`
 `condition.notify()`
### 二、实现线程安全的队列Queue
- (1)、队列定义：队列用于存放多个元素(任务、线程)，是存放各个元素的“池”； 
- (2)、实现：
`实现线程安全的队列`-->`获取当前队列元素个数`-->`往队列放入元素`-->`从队列取出元素`
> 队列可能有多个线程同时操作，因此需要保证线程安全
if: `多个线程同时访问队列元素(保证多个线程获取的串行)`-->`使用“锁”保护队列`
if: `队列元素为空时获取队列元素(阻塞，等待队列不为空)`-->`使用条件变量等待队列元素`

queue.py

### 三、实现基本任务对象task
- task定义:
 - 任务处理逻辑
    实现基本任务对象
	 1、任务参数任务；
	 2、唯一标记(uuid)；
 	 3、任务具体的处理逻辑；


 task.py

 ### 四、线程池简介
 - (1)、什么是线程池
  - 线程池是存放多个线程的容器;
  - CPU调度线程执行后不会销毁线程;
  - 将线程放回线程池重复利用;
 - (2)、为什么需要线程池
  - 线程是稀缺资源，也存在上下文切换，不应该频繁销毁和创建；
  - 架构解耦，线程创建和业务处理解耦，更加优雅;
  - 线程池本来就是使用线程的最佳实践；
 > 阿里的JAVA手册就强制要求使用线程池
 线程资源必须通过线程池来提供，不允许在应用中自行显式创建线程池。
 ___说明:使用线程池的好处是减少在创建和销毁线程所花的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。___

 ### 五、实现任务处理线程ProcessThread
 - (1)、任务处理线程
  - 任务处理线程需要不断的从任务队列里取任务执行;
  - 任务处理线程需要有一个标记，标记线程应该什么时候停止;
 - (2)、实现:
    实现任务处理线程
	 基本属性(任务队列、标记)
	 线程执行的逻辑(run)
	 线程停止(stop)	 
 - (3)、example:
 pool.py
 ### 六、实现任务处理线程池Pool
- (1)、基本功能
 - I、存放一个或多个任务处理线程
 - II、负责多个线程的启停
 - III、管理向线程池的提交任务，下发给线程去执行
- (2)、实现:
    实现任务处理线程池
	 基本属性
	 提交任务(put,batch_put)
	 线程启停(start,join)
	 线程池大小(size)
- (3)、example

task.py

### 六、编写测试用例
 - sublime下，需要Build(Ctrl+b),Cancel Build(Ctrl+Break)
test.py

### 七、实现异步任务处理AsyncTask
##### (1)、我们不知道任务什么时候执行？什么时候执行完成，也不知道返回什么结果?
	a、给任务添加一个标记，任务完成后，则标记为已完成;
	b、任务完成时，可直接获取任务运行结果;             -->  条件变量
	c、任务未完成时，获取任务结果，会阻塞获取线程;
##### (2)、实现AsyncTask
	a、设置运行结果(set_result)
	b、获取运行结果(get_result)
##### (3)、pythonGIL锁
  熟悉python的都知道，在C语言写的python解释器中存在全局解释器锁，由于全局解释器锁的存在，在同一时间内，python解释器只能运行一个线程的代码，这大大影响了python多线程的性能。而这个解释器锁由于历史原因，现在几乎无法消除。
  python GIL 之所以会影响多线程等性能，是因为在多线程的情况下，只有当线程获得了一个全局锁的时候，那么该线程的代码才能运行，而全局锁只有一个，所以使用python多线程，在同一时刻也只有一个线程在运行，因此在即使在多核的情况下也只能发挥出单核的性能。
  既然python在同一时刻下只能运行一个线程的代码，那线程之间是如何调度的呢？ 
  对于有io操作的线程，当一个线程在做io操作的时候，因为io操作不需要cpu，所以，这个时候，python会释放python全局锁，这样其他需要运行的线程就会使用该锁。 
  对于cpu密集型的线程，比如一个线程可能一直需要使用cpu做计算，那么python中会有一个执行指令的计数器，当一个线程执行了一定数量的指令时，该线程就会停止执行并让出当前的锁，这样其他的线程就可以执行代码了。
   
  - 阅读各种语言所提供的异步功能的底层源码
  - 对比其中的相同和不同